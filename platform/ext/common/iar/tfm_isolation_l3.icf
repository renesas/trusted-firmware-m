/*
 * Copyright (c) 2017-2023 Arm Limited. All rights reserved.
 * Copyright (c) 2022 Cypress Semiconductor Corporation (an Infineon company)
 * or an affiliate of Cypress Semiconductor Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/***********  WARNING: This is an auto-generated file. Do not edit!  ***********/

/*
 * Customized region name prefix abbreviation:
 *  LR : A Load region.
 *  ER : A typical execution region.
 *  PT : An empty execution region used as position-tag/address-alignment.
 *
 * No applying customzied prefixes on linker/system reserved/intentional
 * names, such as 'ARM_LIB_STACK'.
 */

#include "region_defs.h"

/* Include file with definitions for section alignments.
 * Note: it should be included after region_defs.h to let platform define
 * default values if needed. */
#include "tfm_s_linker_alignments.h"

/* position tag block : code + RO-data */
define block PT_RO_START with alignment = TFM_LINKER_PT_RO_ALIGNMENT, size = 0 { };
define block PT_RO_END with alignment = TFM_LINKER_PT_RO_ALIGNMENT, size = 0 { };

define block ER_VECTORS with size = S_CODE_VECTOR_TABLE_SIZE {
       readonly section .intvec
};

#ifdef CONFIG_TFM_USE_TRUSTZONE
    /*
     * Place the CMSE Veneers (containing the SG instruction) in a separate
     * at least 32 bytes aligned region so that the SAU can be programmed to
     * just set this region as Non-Secure Callable.
     */
define block ER_VENEER with alignment = TFM_LINKER_VENEERS_ALIGNMENT {section Veneer$$CMSE};

define block VENEER_ALIGN with alignment = TFM_LINKER_VENEERS_ALIGNMENT, size = 0 { };
#endif

define block ER_TFM_CODE with fixed order, alignment = 8 {
    ro section *startup*,
    ro section .text  object *libplatform_s*,
    ro section .rodata object *libplatform_s*,
    ro object *libtfm_spm*
};
    /**** Section for holding partition RO load data */
    /*
     * Sort the partition info by priority to guarantee the initing order.
     * The first loaded partition will be inited at last in SFN model.
     */
define block TFM_SP_LOAD_LIST with alignment = 4 {
    ro section .part_load_priority_lowest object load_info_*.o,
    ro section .part_load_priority_low object load_info_*.o,
    ro section .part_load_priority_normal object load_info_*.o,
    ro section .part_load_priority_high object load_info_*.o,
};

#if defined(S_RAM_CODE_START)
    /* Flash drivers code that gets copied from Flash */
    initialize by copy {
        ro object *libflash_drivers*,
    };

    define block ER_CODE_SRAM  with fixed order, alignment = 4, maximum size = S_RAM_CODE_SIZE {
        rw section .text,
        rw section .rodata,
        rw section .textrw,               /* __ramfunc */
    };

place at address S_RAM_CODE_START { block ER_CODE_SRAM };
#endif

/**** blocks CODE + RO-data definition starts here */
define block ER_TFM_SP_PS_RO  with alignment = TFM_LINKER_APP_ROT_LINKER_CODE_ALIGNMENT
{
    ro section .text object *tfm_*partition_ps.*,
    ro section .rodata object *tfm_*partition_ps.*,
       section TFM_SP_PS_APP-ROT_ATTR_FN,
};
define block ER_TFM_SP_ITS_RO  with alignment = TFM_LINKER_PSA_ROT_LINKER_CODE_ALIGNMENT
{
    ro section .text object *tfm_*partition_its.*,
    ro section .rodata object *tfm_*partition_its.*,
       section TFM_SP_ITS_PSA-ROT_ATTR_FN,
};
define block ER_TFM_SP_CRYPTO_RO  with alignment = TFM_LINKER_PSA_ROT_LINKER_CODE_ALIGNMENT
{
    ro section .text object *tfm_*partition_crypto.*,
    ro section .rodata object *tfm_*partition_crypto.*,
    ro section .text object *mbedcrypto.*,
    ro section .rodata object *mbedcrypto.*,
       section TFM_SP_CRYPTO_PSA-ROT_ATTR_FN,
};
define block ER_TFM_SP_PLATFORM_RO  with alignment = TFM_LINKER_PSA_ROT_LINKER_CODE_ALIGNMENT
{
    ro section .text object *tfm_*partition_platform.*,
    ro section .rodata object *tfm_*partition_platform.*,
       section TFM_SP_PLATFORM_PSA-ROT_ATTR_FN,
};
define block ER_TFM_SP_INITIAL_ATTESTATION_RO  with alignment = TFM_LINKER_PSA_ROT_LINKER_CODE_ALIGNMENT
{
    ro section .text object *tfm_*partition_attestation.*,
    ro section .rodata object *tfm_*partition_attestation.*,
       section TFM_SP_INITIAL_ATTESTATION_PSA-ROT_ATTR_FN,
};
define block ER_TFM_SP_FWU_RO  with alignment = TFM_LINKER_PSA_ROT_LINKER_CODE_ALIGNMENT
{
    ro section .text object *tfm_*partition_fwu*,
    ro section .rodata object *tfm_*partition_fwu*,
       section TFM_SP_FWU_PSA-ROT_ATTR_FN,
};
define block ER_TFM_SP_SECURE_TEST_PARTITION_RO  with alignment = TFM_LINKER_PSA_ROT_LINKER_CODE_ALIGNMENT
{
    ro section .text object *tfm_*partition_secure_client_service.*,
    ro section .rodata object *tfm_*partition_secure_client_service.*,
       section TFM_SP_SECURE_TEST_PARTITION_PSA-ROT_ATTR_FN,
};
define block ER_TFM_SP_IPC_SERVICE_TEST_RO  with alignment = TFM_LINKER_PSA_ROT_LINKER_CODE_ALIGNMENT
{
    ro section .text object *tfm_*partition_ipc_service.*,
    ro section .rodata object *tfm_*partition_ipc_service.*,
       section TFM_SP_IPC_SERVICE_TEST_PSA-ROT_ATTR_FN,
};
define block ER_TFM_SP_IPC_CLIENT_TEST_RO  with alignment = TFM_LINKER_APP_ROT_LINKER_CODE_ALIGNMENT
{
    ro section .text object *tfm_*partition_ipc_client.*,
    ro section .rodata object *tfm_*partition_ipc_client.*,
       section TFM_SP_IPC_CLIENT_TEST_APP-ROT_ATTR_FN,
};
define block ER_TFM_SP_PS_TEST_RO  with alignment = TFM_LINKER_PSA_ROT_LINKER_CODE_ALIGNMENT
{
    ro section .text object *tfm_*partition_ps_test.*,
    ro section .rodata object *tfm_*partition_ps_test.*,
       section TFM_SP_PS_TEST_PSA-ROT_ATTR_FN,
};
define block ER_TFM_SP_SECURE_CLIENT_2_RO  with alignment = TFM_LINKER_APP_ROT_LINKER_CODE_ALIGNMENT
{
    ro section .text object *tfm_*partition_secure_client_2.*,
    ro section .rodata object *tfm_*partition_secure_client_2.*,
       section TFM_SP_SECURE_CLIENT_2_APP-ROT_ATTR_FN,
};
define block ER_TFM_SP_SLIH_TEST_RO  with alignment = TFM_LINKER_APP_ROT_LINKER_CODE_ALIGNMENT
{
    ro section .text object *tfm_*partition_slih_test.*,
    ro section .rodata object *tfm_*partition_slih_test.*,
       section TFM_SP_SLIH_TEST_APP-ROT_ATTR_FN,
};
/**** blocks CODE + RO-data definition ends here*/

/**** Block Unprivileged Secure code + RO-data definition starts here */
define block TFM_UNPRIV_CODE with alignment = TFM_LINKER_UNPRIV_CODE_ALIGNMENT {
    section SFN,
    readonly
};


/* position tag block : base address of secure data area ( S_DATA_START)*/
define block PT_SECURE_DATA_START with alignment = TFM_LINKER_SECURE_DATA_ALIGNMENT, size = 0 { };
define block PT_PRIV_RWZI_START with alignment = TFM_LINKER_PT_PRIV_RWZI_ALIGNMENT, size = 0 { };

define block TFM_SHARED_DATA with alignment = TFM_LINKER_BL2_SHARED_DATA_ALIGNMENT, size = BOOT_TFM_SHARED_DATA_SIZE { };
define block ARM_LIB_STACK with alignment = TFM_LINKER_MSP_STACK_ALIGNMENT, size = S_MSP_STACK_SIZE - 0x8 { };
define block STACKSEAL with size = 0x8 { };

#if defined(ENABLE_HEAP)
    define block HEAP         with alignment = 8, size = S_HEAP_SIZE { };
    define block ARM_LIB_HEAP {block HEAP};
    keep {block HEAP, block ARM_LIB_HEAP};
#endif

define block ER_TFM_DATA          with alignment = 8 {readwrite};

/* The runtime partition placed order is same as load partition */
define block ER_PART_RT_POOL      with alignment = 4 {
    zi section .bss.part_runtime_priority_lowest,
    zi section .bss.part_runtime_priority_low,
    zi section .bss.part_runtime_priority_normal,
    zi section .bss.part_runtime_priority_high,
};

/* The runtime service placed order is same as load partition */
define block ER_SERV_RT_POOL      with alignment = 4 {
    zi section .bss.serv_runtime_priority_lowest,
    zi section .bss.serv_runtime_priority_low,
    zi section .bss.serv_runtime_priority_normal,
    zi section .bss.serv_runtime_priority_high,
};

keep {block ER_PART_RT_POOL, block ER_SERV_RT_POOL};

    /**** Blocks RWZI definition starts here */
    /* Position  tag : start Block :*/
    define block PT_TFM_SP_ITS_PRIVATE_DATA_START with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };

    define block ER_TFM_SP_ITS_RWZI with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT {
	rw section .data object *tfm_*partition_its.*,
	rw section .bss  object *tfm_*partition_its.*,
	section TFM_SP_ITS_PSA-ROT_ATTR_RW,
	section TFM_SP_ITS_PSA-ROT_ATTR_ZI,
};
/* Position  tag : start Block :*/
    define block PT_TFM_SP_ITS_PRIVATE_DATA_END with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };
    /* Position  tag : start Block :*/
    define block PT_TFM_SP_CRYPTO_PRIVATE_DATA_START with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };

    define block ER_TFM_SP_CRYPTO_RWZI with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT {
	rw section .data object *tfm_*partition_crypto.*,
	rw section .bss  object *tfm_*partition_crypto.*,
	rw section .data object *mbedcrypto.*,
	rw section .bss  object *mbedcrypto.*,
	section TFM_SP_CRYPTO_PSA-ROT_ATTR_RW,
	section TFM_SP_CRYPTO_PSA-ROT_ATTR_ZI,
};
/* Position  tag : start Block :*/
    define block PT_TFM_SP_CRYPTO_PRIVATE_DATA_END with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };
    /* Position  tag : start Block :*/
    define block PT_TFM_SP_PLATFORM_PRIVATE_DATA_START with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };

    define block ER_TFM_SP_PLATFORM_RWZI with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT {
	rw section .data object *tfm_*partition_platform.*,
	rw section .bss  object *tfm_*partition_platform.*,
	section TFM_SP_PLATFORM_PSA-ROT_ATTR_RW,
	section TFM_SP_PLATFORM_PSA-ROT_ATTR_ZI,
};
/* Position  tag : start Block :*/
    define block PT_TFM_SP_PLATFORM_PRIVATE_DATA_END with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };
    /* Position  tag : start Block :*/
    define block PT_TFM_SP_INITIAL_ATTESTATION_PRIVATE_DATA_START with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };

    define block ER_TFM_SP_INITIAL_ATTESTATION_RWZI with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT {
	rw section .data object *tfm_*partition_attestation.*,
	rw section .bss  object *tfm_*partition_attestation.*,
	section TFM_SP_INITIAL_ATTESTATION_PSA-ROT_ATTR_RW,
	section TFM_SP_INITIAL_ATTESTATION_PSA-ROT_ATTR_ZI,
};
/* Position  tag : start Block :*/
    define block PT_TFM_SP_INITIAL_ATTESTATION_PRIVATE_DATA_END with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };
    /* Position  tag : start Block :*/
    define block PT_TFM_SP_FWU_PRIVATE_DATA_START with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };

    define block ER_TFM_SP_FWU_RWZI with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT {
	rw section .data object *tfm_*partition_fwu*,
	rw section .bss  object *tfm_*partition_fwu*,
	section TFM_SP_FWU_PSA-ROT_ATTR_RW,
	section TFM_SP_FWU_PSA-ROT_ATTR_ZI,
};
/* Position  tag : start Block :*/
    define block PT_TFM_SP_FWU_PRIVATE_DATA_END with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };
    /* Position  tag : start Block :*/
    define block PT_TFM_SP_SECURE_TEST_PARTITION_PRIVATE_DATA_START with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };

    define block ER_TFM_SP_SECURE_TEST_PARTITION_RWZI with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT {
	rw section .data object *tfm_*partition_secure_client_service.*,
	rw section .bss  object *tfm_*partition_secure_client_service.*,
	section TFM_SP_SECURE_TEST_PARTITION_PSA-ROT_ATTR_RW,
	section TFM_SP_SECURE_TEST_PARTITION_PSA-ROT_ATTR_ZI,
};
/* Position  tag : start Block :*/
    define block PT_TFM_SP_SECURE_TEST_PARTITION_PRIVATE_DATA_END with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };
    /* Position  tag : start Block :*/
    define block PT_TFM_SP_IPC_SERVICE_TEST_PRIVATE_DATA_START with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };

    define block ER_TFM_SP_IPC_SERVICE_TEST_RWZI with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT {
	rw section .data object *tfm_*partition_ipc_service.*,
	rw section .bss  object *tfm_*partition_ipc_service.*,
	section TFM_SP_IPC_SERVICE_TEST_PSA-ROT_ATTR_RW,
	section TFM_SP_IPC_SERVICE_TEST_PSA-ROT_ATTR_ZI,
};
/* Position  tag : start Block :*/
    define block PT_TFM_SP_IPC_SERVICE_TEST_PRIVATE_DATA_END with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };
    /* Position  tag : start Block :*/
    define block PT_TFM_SP_PS_TEST_PRIVATE_DATA_START with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };

    define block ER_TFM_SP_PS_TEST_RWZI with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT {
	rw section .data object *tfm_*partition_ps_test.*,
	rw section .bss  object *tfm_*partition_ps_test.*,
	section TFM_SP_PS_TEST_PSA-ROT_ATTR_RW,
	section TFM_SP_PS_TEST_PSA-ROT_ATTR_ZI,
};
/* Position  tag : start Block :*/
    define block PT_TFM_SP_PS_TEST_PRIVATE_DATA_END with alignment = TFM_LINKER_PSA_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };

/**** block Position tag  PSA RoT RWZI ends definition  */
define block PT_PRIV_RWZI_END with alignment = TFM_LINKER_PT_PRIV_RWZI_ALIGNMENT, size = 0 { };

    /* Position  tag : start Block :*/
    define block PT_TFM_SP_PS_PRIVATE_DATA_START with alignment = TFM_LINKER_APP_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };

    define block ER_TFM_SP_PS_RWZI with alignment = TFM_LINKER_APP_ROT_LINKER_DATA_ALIGNMENT {
	rw section .data object *tfm_*partition_ps.*,
	rw section .bss  object *tfm_*partition_ps.*,
	section TFM_SP_PS_APP-ROT_ATTR_RW,
	section TFM_SP_PS_APP-ROT_ATTR_ZI,
};
/* Position  tag : start Block :*/
    define block PT_TFM_SP_PS_PRIVATE_DATA_END with alignment = TFM_LINKER_APP_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };
    /* Position  tag : start Block :*/
    define block PT_TFM_SP_IPC_CLIENT_TEST_PRIVATE_DATA_START with alignment = TFM_LINKER_APP_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };

    define block ER_TFM_SP_IPC_CLIENT_TEST_RWZI with alignment = TFM_LINKER_APP_ROT_LINKER_DATA_ALIGNMENT {
	rw section .data object *tfm_*partition_ipc_client.*,
	rw section .bss  object *tfm_*partition_ipc_client.*,
	section TFM_SP_IPC_CLIENT_TEST_APP-ROT_ATTR_RW,
	section TFM_SP_IPC_CLIENT_TEST_APP-ROT_ATTR_ZI,
};
/* Position  tag : start Block :*/
    define block PT_TFM_SP_IPC_CLIENT_TEST_PRIVATE_DATA_END with alignment = TFM_LINKER_APP_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };
    /* Position  tag : start Block :*/
    define block PT_TFM_SP_SECURE_CLIENT_2_PRIVATE_DATA_START with alignment = TFM_LINKER_APP_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };

    define block ER_TFM_SP_SECURE_CLIENT_2_RWZI with alignment = TFM_LINKER_APP_ROT_LINKER_DATA_ALIGNMENT {
	rw section .data object *tfm_*partition_secure_client_2.*,
	rw section .bss  object *tfm_*partition_secure_client_2.*,
	section TFM_SP_SECURE_CLIENT_2_APP-ROT_ATTR_RW,
	section TFM_SP_SECURE_CLIENT_2_APP-ROT_ATTR_ZI,
};
/* Position  tag : start Block :*/
    define block PT_TFM_SP_SECURE_CLIENT_2_PRIVATE_DATA_END with alignment = TFM_LINKER_APP_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };
    /* Position  tag : start Block :*/
    define block PT_TFM_SP_SLIH_TEST_PRIVATE_DATA_START with alignment = TFM_LINKER_APP_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };

    define block ER_TFM_SP_SLIH_TEST_RWZI with alignment = TFM_LINKER_APP_ROT_LINKER_DATA_ALIGNMENT {
	rw section .data object *tfm_*partition_slih_test.*,
	rw section .bss  object *tfm_*partition_slih_test.*,
	section TFM_SP_SLIH_TEST_APP-ROT_ATTR_RW,
	section TFM_SP_SLIH_TEST_APP-ROT_ATTR_ZI,
};
/* Position  tag : start Block :*/
    define block PT_TFM_SP_SLIH_TEST_PRIVATE_DATA_END with alignment = TFM_LINKER_APP_ROT_LINKER_DATA_ALIGNMENT, size = 0 { };

#if defined(CONFIG_TFM_PARTITION_META)
define block TFM_SP_META_PTR with alignment = TFM_LINKER_SP_META_PTR_ALIGNMENT {
    zi section .bss.SP_META_PTR_SPRTL_INST
       };
#endif

#ifdef RAM_VECTORS_SUPPORT
define block ER_RAM_VECTORS      with alignment = TFM_LINKER_RAM_VECTORS_ALIGNMENT { section .ramvec };
#endif

define block PT_SRAM_WATERMARK with alignment = TFM_LINKER_SECURE_DATA_ALIGNMENT, size = 0 { };

/* Define Flash content */
define block LR_CODE with fixed order {
    block ER_VECTORS,
#ifdef CONFIG_TFM_USE_TRUSTZONE
    block ER_VENEER,
    block VENEER_ALIGN,
#endif
    block PT_RO_START,
    block ER_TFM_CODE,
    block TFM_SP_LOAD_LIST,
    /**** PSA RoT CODE + RO-data starts here */
    block ER_TFM_SP_ITS_RO,
    block ER_TFM_SP_CRYPTO_RO,
    block ER_TFM_SP_PLATFORM_RO,
    block ER_TFM_SP_INITIAL_ATTESTATION_RO,
    block ER_TFM_SP_FWU_RO,
    block ER_TFM_SP_SECURE_TEST_PARTITION_RO,
    block ER_TFM_SP_IPC_SERVICE_TEST_RO,
    block ER_TFM_SP_PS_TEST_RO,
    /**** APPLICATION RoT RO CODE + data starts here */
    block ER_TFM_SP_PS_RO,
    block ER_TFM_SP_IPC_CLIENT_TEST_RO,
    block ER_TFM_SP_SECURE_CLIENT_2_RO,
    block ER_TFM_SP_SLIH_TEST_RO,
    block TFM_UNPRIV_CODE,
    block PT_RO_END,
};


do not initialize  {
   section .noinit,
   rw section .ramvec
   };
initialize by copy with packing = none { readwrite }
#ifndef S_RAM_CODE_START
    except { section .textrw }
#endif
       ;
if (isdefinedsymbol(__USE_DLIB_PERTHREAD))
{
    // Required in a multi-threaded application
    initialize by copy { section __DLIB_PERTHREAD };
}


/* Place Flash content */
place at address S_CODE_START         { block LR_CODE };
/* Define RAM content */
define block DATA with fixed order {
    /**** Base address of secure data area */
    block PT_SECURE_DATA_START,
    block PT_PRIV_RWZI_START,
    block TFM_SHARED_DATA,
    block ARM_LIB_STACK,
    block STACKSEAL,
#if defined(ENABLE_HEAP)
    block ARM_LIB_HEAP,
#endif
    block ER_TFM_DATA,
    block ER_PART_RT_POOL,
    block ER_SERV_RT_POOL,
   /* place PSA-ROT data  */
    block PT_TFM_SP_ITS_PRIVATE_DATA_START,
    block ER_TFM_SP_ITS_RWZI,
    block PT_TFM_SP_ITS_PRIVATE_DATA_END,
    block PT_TFM_SP_CRYPTO_PRIVATE_DATA_START,
    block ER_TFM_SP_CRYPTO_RWZI,
    block PT_TFM_SP_CRYPTO_PRIVATE_DATA_END,
    block PT_TFM_SP_PLATFORM_PRIVATE_DATA_START,
    block ER_TFM_SP_PLATFORM_RWZI,
    block PT_TFM_SP_PLATFORM_PRIVATE_DATA_END,
    block PT_TFM_SP_INITIAL_ATTESTATION_PRIVATE_DATA_START,
    block ER_TFM_SP_INITIAL_ATTESTATION_RWZI,
    block PT_TFM_SP_INITIAL_ATTESTATION_PRIVATE_DATA_END,
    block PT_TFM_SP_FWU_PRIVATE_DATA_START,
    block ER_TFM_SP_FWU_RWZI,
    block PT_TFM_SP_FWU_PRIVATE_DATA_END,
    block PT_TFM_SP_SECURE_TEST_PARTITION_PRIVATE_DATA_START,
    block ER_TFM_SP_SECURE_TEST_PARTITION_RWZI,
    block PT_TFM_SP_SECURE_TEST_PARTITION_PRIVATE_DATA_END,
    block PT_TFM_SP_IPC_SERVICE_TEST_PRIVATE_DATA_START,
    block ER_TFM_SP_IPC_SERVICE_TEST_RWZI,
    block PT_TFM_SP_IPC_SERVICE_TEST_PRIVATE_DATA_END,
    block PT_TFM_SP_PS_TEST_PRIVATE_DATA_START,
    block ER_TFM_SP_PS_TEST_RWZI,
    block PT_TFM_SP_PS_TEST_PRIVATE_DATA_END,

    block PT_PRIV_RWZI_END,

   /* place APP-ROT data  */
    block PT_TFM_SP_PS_PRIVATE_DATA_START,
    block ER_TFM_SP_PS_RWZI,
    block PT_TFM_SP_PS_PRIVATE_DATA_END,
    block PT_TFM_SP_IPC_CLIENT_TEST_PRIVATE_DATA_START,
    block ER_TFM_SP_IPC_CLIENT_TEST_RWZI,
    block PT_TFM_SP_IPC_CLIENT_TEST_PRIVATE_DATA_END,
    block PT_TFM_SP_SECURE_CLIENT_2_PRIVATE_DATA_START,
    block ER_TFM_SP_SECURE_CLIENT_2_RWZI,
    block PT_TFM_SP_SECURE_CLIENT_2_PRIVATE_DATA_END,
    block PT_TFM_SP_SLIH_TEST_PRIVATE_DATA_START,
    block ER_TFM_SP_SLIH_TEST_RWZI,
    block PT_TFM_SP_SLIH_TEST_PRIVATE_DATA_END,

#if defined(CONFIG_TFM_PARTITION_META)
    block TFM_SP_META_PTR,
#endif

#ifdef RAM_VECTORS_SUPPORT
    block ER_RAM_VECTORS,
#endif

    block PT_SRAM_WATERMARK,
 /* Make sure that the sections allocated in the SRAM does not exceed the
     * size of the SRAM available.
     */
};

place at address S_DATA_START          { block DATA };

    /* Reserved place for NS application.
     * No code will be placed here, just address of this region is used in the
     * secure code to configure certain HW components. This generates an empty
     * execution region description warning during linking.
     */
define block LR_NS_PARTITION with size = NS_PARTITION_SIZE { };
place at address NS_PARTITION_START { block LR_NS_PARTITION };

#ifdef BL2
    /* Reserved place for new image in case of firmware upgrade.
     * No code will be placed here, just address of this region is used in the
     * secure code to configure certain HW components. This generates an empty
     * execution region description warning during linking.
     */
define block LR_SECONDARY_PARTITION with size = SECONDARY_PARTITION_SIZE { };
place at address SECONDARY_PARTITION_START { block LR_SECONDARY_PARTITION };
#endif /* BL2 */
